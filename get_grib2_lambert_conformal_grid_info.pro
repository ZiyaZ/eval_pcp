PRO GET_GRIB2_LAMBERT_CONFORMAL_GRID_INFO, $
  GRIBFile, $                   ; IN - GRIB2 file name (no path)
  GRIBDir, $                    ; IN - Location of GRIB2 file
  ScratchDir, $                 ; IN - Scratch directory for header file
  FieldPattern, $               ; IN - Expression to match for field
  nx, $                         ; OUT - GRIB data columns
  ny, $                         ; OUT - GRIB data rows
  lat1, $                       ; OUT - latitude of lower left grid cell
  lon1, $                       ; OUT - longitude of lower left grid cell
  lonV, $                        ; OUT - orientation lon.
  latd, $                       ; OUT - lat. where grid spacing is defined
  latin1, $                     ; OUT - first std. parallel
  latin2, $                     ; OUT - second std. parallel
  latsp, $                      ; OUT - south pole lat.
  lonsp, $                      ; OUT - south pole lon.
  dx, $                         ; OUT - grid spacing in x, meters
  dy, $                         ; OUT - grid spacing in y, meters
  gggiStatus

;+
; Get grid and projection information for GRIB2-encoded gridded data
; on a Lambert conformal projection.
;
; :Params:
;
;     GRIBFile : in, required, type=STRING
;         The GRIB2 file name, not including its directory location.
;     GRIBDir : in, required, type=STRING
;         The path to the directory where the GRIB2 file is located.
;     ScratchDir : in, required, type=STRING
;         The directory where temporary files generated by this
;         procedure are stored.
;     FieldPattern : in, required, type=STRING
;         An extended regular expression used with the wgrib2 "-match"
;         command during decoding to identify a unique (hopefully)
;         GRIB2 record. This pattern nearly always includes a GRIB
;         parameter abbreviation. See
;         `http://www.nco.ncep.noaa.gov/pmb/docs/on388/table2.html <http://www.nco.ncep.noaa.gov/pmb/docs/on388/table2.html>`
;     nx : out, type=LONG
;         The number of columns in the GRIB2 record data.
;     ny : out, type=LONG
;         The number of rows in the GRIB2 record data.
;     lat1 : out, type=DOUBLE
;         The lower left grid cell center latitude, degrees.
;     lon1 : out, type=DOUBLE
;         The lower left grid cell center longitude, degrees.
;     lonV : out, type=DOUBLE
;         The orientation longitude, which is where the origin of the
;         projection x coordinate falls, degrees.
;     latd : out, type=DOUBLE
;         The latitude where the grid spacing is defined, degrees.
;     latin1 : out, type=DOUBLE
;         The first standard parallel for the projection, degrees.
;     latin2 : out, type=DOUBLE
;         The second standard parallel for the projection, degrees.
;     latsp : out, type=DOUBLE
;         The south pole latitude, degrees.
;     lonsp : out, type=DOUBLE
;         The south pole longitude, degrees.
;     dx : out, type=DOUBLE
;         The grid spacing in x, meters.
;     dy : out, type=DOUBLE
;         The grid spacing in y, meters.
;     gggiStatus : out, type=INT
;         An exit status for this procedure; 0 = failure, 1 =
;         success.
;-

  COMMON info, Message ; used by USR_MSG and ERR_MSG

;+
; Initialize procedure status to 0 (fail).
;-
  gggiStatus = 0

;+
; Check arguments for correct type and valid contents.
;-
  if NOT(ISA(GRIBDir, 'STRING')) then begin
      ERR_MSG, 'Path to GRIB directory must be a STRING.'
      RETURN
  endif

  if NOT(FILE_TEST(GRIBDir, /DIRECTORY)) then begin
      ERR_MSG, 'GRIB directory "' + GRIBDir + '" not found.'
      RETURN
  endif

  if NOT(FILE_TEST(GRIBDir, /READ)) then begin
      ERR_MSG, 'GRIB directory "' + GRIBDir + '" not readable.'
      RETURN
  endif

  if NOT(ISA(GRIBFile, 'STRING')) then begin
      ERR_MSG, 'GRIB file must be a STRING.'
      RETURN
  endif

  GRIBFilePath = GRIBDir + '/' + GRIBFile
  if NOT(FILE_TEST(GRIBFilePath)) then begin
      ERR_MSG, 'File "' + GRIBFilePath + '" not found.'
      RETURN
  endif

  if NOT(ISA(scratchDir, 'STRING')) then begin
      ERR_MSG, 'Location of scratch directory must be a STRING.'
      RETURN
  endif

  if NOT(FILE_TEST(scratchDir, /DIRECTORY)) then begin
      ERR_MSG, 'Scratch directory "' + scratchDir + '" not found.'
      RETURN
  endif

  if NOT(FILE_TEST(scratchDir, /READ)) then begin
      ERR_MSG, 'Scratch directory "' + scratchDir + '" not readable.'
      RETURN
  endif

  if NOT(FILE_TEST(scratchDir, /WRITE)) then begin
      ERR_MSG, 'Scratch directory "' + scratchDir + '" not writeable.'
      RETURN
  endif

  if NOT(ISA(FieldPattern, 'STRING')) then begin
      ERR_MSG, 'Extended regular expression for matching the GRIB ' + $
               'record must be a STRING.'
      RETURN
  endif

;+
; Deal with zipped files. If the GRIBFilePath ends with one of the
; extensions below, this procedure will attempt to use the gzip
; utility to decompress a copy of the file before reading it.
;-
  gz1Pos = STRPOS(GRIBFile, '.gz', 2, /REVERSE_SEARCH, /REVERSE_OFFSET)
  gz2pos = STRPOS(GRIBFile, '-gz', 2, /REVERSE_SEARCH, /REVERSE_OFFSET)
  z1Pos = STRPOS(GRIBFile, '.z', 1, /REVERSE_SEARCH, /REVERSE_OFFSET)
  z2Pos = STRPOS(GRIBFile, '-z', 1, /REVERSE_SEARCH, /REVERSE_OFFSET)
  z3Pos = STRPOS(GRIBFile, '_z', 1, /REVERSE_SEARCH, /REVERSE_OFFSET)
  z4Pos = STRPOS(GRIBFile, '.Z', 1, /REVERSE_SEARCH, /REVERSE_OFFSET)
  zipPos = [gz1Pos, gz2Pos, z1Pos, z2Pos, z3Pos, z4Pos]
  ind = WHERE(zipPos ne -1, count)
  if (count eq 1) then begin

;+
;     Copy the file to the ScratchDir.
;-
      cmd = 'cp --preserve=mode,timestamps ' + $
            GRIBFilePath + ' ' + ScratchDir
      SPAWN, cmd, EXIT_STATUS = status
      if (status ne 0) then begin
          ERR_MSG, 'Failed to copy ' + GRIBFilePath + ' to ' + ScratchDir
          RETURN
      endif
      if NOT(FILE_TEST(ScratchDir + '/' + GRIBFile)) then begin
          ERR_MSG, 'File copy ' + ScratchDir + '/' + GRIBFile + $
                   ' not found.'
          RETURN
      endif

      ind = ind[0]
      cmd = 'gzip -d ' + ScratchDir + '/' + GRIBFile
      SPAWN, cmd, EXIT_STATUS = status
      if (status ne 0) then begin
          ERR_MSG, 'Command "' + cmd + '" failed.'
          RETURN
      endif
      tmpGRIBFile = STRMID(GRIBFile, 0, zipPos[ind])
      if NOT(FILE_TEST(ScratchDir + '/' + tmpGRIBFile)) then begin
          ERR_MSG, 'Output file missing after command "gzip -d ' + $
                   ScratchDir + '/' + GRIBFile + '".'
          RETURN
      endif

      inputPath = ScratchDir + '/' + tmpGRIBFile

  endif else begin

      tmpGRIBFile = GRIBFile
      inputPath = GRIBFilePath

  endelse

;+
; Decode the GRIB2 header.
; Supposedly -V = -vt -lev -ftime -var -ens -stats -grid
;-
  cmd = 'wgrib2 -grid -end -order we:sn -match "' + FieldPattern + '" ' + $
        inputPath
  SPAWN, cmd, hdr, EXIT_STATUS = status
  if (status ne 0) then begin
      ERR_MSG, 'Command "' + cmd + '" failed.'
      RETURN
  endif

;+
; Delete the temporary copy if gzip was used.
;-
  if (inputPath eq ScratchDir + '/' + tmpGRIBFile) then $
      FILE_DELETE, inputPath

;+
; Check the header size.  The wgrib2 program likes to bomb and report
; success.
;-
  if (N_ELEMENTS(hdr) lt 6) then begin
      ERR_MSG, 'Invalid output header (at least 6 elements expected, ' + $
               'found ' + STRCRA(N_ELEMENTS(hdr)) + ')'
      RETURN
  endif

;+
; Read the header.
;-
  inventory = hdr[0]

;+
; First line: "grid_template=30"
;-
  if NOT(STREGEX(inventory, 'grid_template=30', /BOOLEAN)) then begin
      ERR_MSG, 'Failed to match "grid_template=30" in GRIB inventory. ' + $
               'Header reads "' + inventory + '"'
      RETURN
  endif

;+
; Second line: grid dimensions.
;-
  inventory = hdr[1]
  if NOT(STREGEX(inventory, 'Lambert Conformal', /BOOLEAN)) $
      then begin
      ERR_MSG, 'Failed to match "Lambert Conformal" in GRIB inventory. ' + $
               'Header reads "' + inventory + '"'
      RETURN
  endif

  if NOT(STREGEX(inventory, '\([0-9]+ x [0-9]+\)', /BOOLEAN)) $
      then begin
      ERR_MSG, 'Failed to get grid dimensions from GRIB inventory. ' + $
               'Header reads "' + inventory + '"'
      RETURN
  endif

  dims = STREGEX(inventory, '\([0-9]+ x [0-9]+\)', /EXTRACT)

  nxStr = STREGEX(dims, '\([0-9]+ x', /EXTRACT)
  nx = LONG(STRMID(nxStr, 1, STRLEN(nxStr) - 3))

  nyStr = STREGEX(dims, 'x [0-9]+\)', /EXTRACT)
  ny = LONG(STRMID(nyStr, 2, STRLEN(nyStr) - 3))

;+
; Third line: origin.
;-
  inventory = hdr[2]

  if NOT(STREGEX(inventory, 'Lat1 [-0-9.]* ', /BOOLEAN)) then begin
      ERR_MSG, 'Failed to locate origin latitude in GRIB inventory. ' + $
               'Header reads "' + inventory + '"'
      RETURN
  endif
  c1 = STRPOS(inventory, 'Lat1 ')
  if (c1 eq -1) then begin
      ERR_MSG, 'Unexpected format for origin latitude in GRIB inventory. ' + $
               'Header reads "' + inventory + '"'
      RETURN
  endif
  c2 = STRPOS(inventory, ' ', c1 + 5)
  if (c2 eq -1) then begin
      ERR_MSG, 'Unexpected format for origin latitude in GRIB inventory. ' + $
               'Header reads "' + inventory + '"'
      RETURN
  endif
  lat1 = DOUBLE(STRMID(inventory, c1 + 5, c2 - c1 - 5))

  if NOT(STREGEX(inventory, 'Lon1 [0-9.]* ', /BOOLEAN)) then begin
      ERR_MSG, 'Failed to locate origin longitude in GRIB inventory. ' + $
               'Header reads "' + inventory + '"'
      RETURN
  endif
  c1 = STRPOS(inventory, 'Lon1 ')
  if (c1 eq -1) then begin
      ERR_MSG, 'Unexpected format for origin longitude in GRIB inventory. ' + $
               'Header reads "' + inventory + '"'
      RETURN
  endif
  c2 = STRPOS(inventory, ' ', c1 + 5)
  if (c2 eq -1) then begin
      ERR_MSG, 'Unexpected format for origin longitude in GRIB inventory. ' + $
               'Header reads "' + inventory + '"'
      RETURN
  endif
  lon1 = DOUBLE(STRMID(inventory, c1 + 5, c2 - c1 - 5))
  if (lon1 gt 180.0D) then lon1 = lon1 - 360.0D

  if NOT(STREGEX(inventory, 'LoV [0-9.]*$', /BOOLEAN)) then begin
      ERR_MSG, 'Failed to locate orientation longitude in GRIB inventory. ' + $
               'Header reads "' + inventory + '"'
      RETURN
  endif
  c1 = STRPOS(inventory, 'LoV ')
  if (c1 eq -1) then begin
      ERR_MSG, 'Unexpected format for orientation longitude in ' + $
               'GRIB inventory. ' + $
               'Header reads "' + inventory + '"'
      RETURN
  endif
  c2 = STRLEN(inventory)

  lonV = DOUBLE(STRMID(inventory, c1 + 4, c2 - c1 - 4))
  if (lonV gt 180.0D) then lonV = lonV - 360.0D

;+
; Fourth line: standard parallels
;-
  inventory = hdr[3]

  if NOT(STREGEX(inventory, 'LatD [-0-9.]* ', /BOOLEAN)) then begin
      ERR_MSG, 'Failed to locate grid spacing latitude in ' + $
               'GRIB inventory. ' + $
               'Header reads "' + inventory + '"'
      RETURN
  endif
  c1 = STRPOS(inventory, 'LatD ')
  if (c1 eq -1) then begin
      ERR_MSG, 'Unexpected format for grid spacing latitude in ' + $
               'GRIB inventory. ' + $
               'Header reads "' + inventory + '"'
      RETURN
  endif
  c2 = STRPOS(inventory, ' ', c1 + 5)
  if (c2 eq -1) then begin
      ERR_MSG, 'Unexpected format for grid spacing latitude in ' + $
               'GRIB inventory. ' + $
               'Header reads "' + inventory + '"'
      RETURN
  endif
  latd = DOUBLE(STRMID(inventory, c1 + 5, c2 - c1 - 5))
 
  if NOT(STREGEX(inventory, 'Latin1 [-0-9.]* ', /BOOLEAN)) then begin
      ERR_MSG, 'Failed to locate first standard parallel in ' + $
               'GRIB inventory. ' + $
               'Header reads "' + inventory + '"'
      RETURN
  endif
  c1 = STRPOS(inventory, 'Latin1 ')
  if (c1 eq -1) then begin
      ERR_MSG, 'Unexpected format for 1st standard parallel in ' + $
               'GRIB inventory. ' + $
               'Header reads "' + inventory + '"'
      RETURN
  endif
  c2 = STRPOS(inventory, ' ', c1 + 7)
  if (c2 eq -1) then begin
      ERR_MSG, 'Unexpected format for 1st standard parallel in ' + $
               'GRIB inventory. ' + $
               'Header reads "' + inventory + '"'
      RETURN
  endif
  latin1 = DOUBLE(STRMID(inventory, c1 + 7, c2 - c1 - 7))

  if NOT(STREGEX(inventory, 'Latin2 [-0-9.]*$', /BOOLEAN)) then begin
      ERR_MSG, 'Failed to locate second standard parallel in ' + $
               'GRIB inventory. ' + $
               'Header reads "' + inventory + '"'
      RETURN
  endif
  c1 = STRPOS(inventory, 'Latin2 ')
  if (c1 eq -1) then begin
      ERR_MSG, 'Unexpected format for 2nd standard parallel in ' + $
               'GRIB inventory. ' + $
               'Header reads "' + inventory + '"'
      RETURN
  endif
  c2 = STRLEN(inventory)
  latin2 = DOUBLE(STRMID(inventory, c1 + 7, c2 - c1 - 7))

;+
; Fifth line: south pole.
;-
  inventory = hdr[4]

  if NOT(STREGEX(inventory, 'LatSP [-0-9.]* ', /BOOLEAN)) then begin
      ERR_MSG, 'Failed to locate south pole latitude in GRIB inventory. ' + $
               'Header reads "' + inventory + '"'
      RETURN
  endif
  c1 = STRPOS(inventory, 'LatSP ')
  if (c1 eq -1) then begin
      ERR_MSG, 'Unexpected format for south pole latitude in ' + $
               'GRIB inventory. ' + $
               'Header reads "' + inventory + '"'
      RETURN
  endif
  c2 = STRPOS(inventory, ' ', c1 + 6)
  if (c2 eq -1) then begin
      ERR_MSG, 'Unexpected format for south pole latitude in ' + $
               'GRIB inventory. ' + $
               'Header reads "' + inventory + '"'
      RETURN
  endif
  latsp = DOUBLE(STRMID(inventory, c1 + 6, c2 - c1 - 6))

  if NOT(STREGEX(inventory, 'LonSP [0-9.]*$', /BOOLEAN)) then begin
      ERR_MSG, 'Failed to locate south pole longitude in ' + $
               'GRIB inventory. '+ $
               'Header reads "' + inventory + '"'
      RETURN
  endif
  c1 = STRPOS(inventory, 'LonSP ')
  if (c1 eq -1) then begin
      ERR_MSG, 'Unexpected format for south pole longitude in ' + $
               'GRIB inventory. ' + $
               'Header reads "' + inventory + '"'
      RETURN
  endif
  c2 = STRLEN(inventory)
  lonsp = DOUBLE(STRMID(inventory, c1 + 6, c2 - c1 - 6))

;+
; Sixth line: grid spacing.
;-
  inventory = hdr[5]

  if NOT(STREGEX(inventory, 'Dx [0-9.]* m Dy [0-9.]* m', /BOOLEAN)) $
      then begin
      ERR_MSG, 'Failed to locate grid spacing in GRIB inventory. ' + $
               'Header reads "' + inventory + '"'
      RETURN
  endif
  dims = STREGEX(inventory, 'Dx [0-9.]* m Dy [0-9.]* m', /EXTRACT)

  c1 = STRPOS(dims, 'Dx ')
  c2 = STRPOS(dims, ' m Dy ', c1 + 3)
  dx = DOUBLE(STRMID(dims, c1 + 3, c2 - c1 - 3))

  c1 = STRPOS(dims, 'Dy ')
  c2 = STRPOS(dims, ' ', c1 + 3)
  dy = DOUBLE(STRMID(dims, c1 + 3, c2 - c1 - 3))

  gggiStatus = 1

  RETURN

end
