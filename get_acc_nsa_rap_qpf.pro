PRO GET_ACC_NSA_RAP_QPF, $
    AccEndDate_YYYYMMDDHH, $     ; accum. end date/time
    DurationHours, $             ; accum. duration, usually 24
    TargetFcstHour, $            ; target forecast hour, usually 3
    MinSubFcstHour, $            ; min. substitute forecast hour, usually 1
    MaxSubFcstHour, $            ; max. substitute forecast hour, usually 6
    ScratchDir, $                ; location for temporary/cache files
    PGHost, $                    ; 'ddb0' or 'odb0'
    Ndv, $                       ; no data value to apply to all data
    accNonSnowGrid, $
    accSnowGrid, $
    NSA_GRID_INFO = NSAGridInfo, $
    VERBOSE = verbose

;+
; Get accumulated hourly RAP total precipitation as generated by the
; 2017-18 versions of get_model_data, combine_model_data, and
; scale_model_data in the National Snow Analysis forcing engine.
;-

  COMMON info, message

  accQPFGrid = !NULL

;+
; Error handler for anything the main procedure code misses. Example:
; RESTORE encounters a file that was truncated because a disk filled.
;-
;  CATCH, errorStatus
;  if (errorStatus ne 0) then begin
;      ERR_MSG, !Error_State.Msg
;      RETURN
;  endif

;+
; Check arguments for correct type and valid contents.
;-
  if NOT(ISA(AccEndDate_YYYYMMDDHH, 'STRING')) then begin
      ERR_MSG, 'Target accumulation end date/time argument ' + $
               'must be a STRING.'
      RETURN
  endif
  if (STRLEN(AccEndDate_YYYYMMDDHH) ne 10) then begin
      ERR_MSG, 'Invalid target accumulation end date/time "' + $
               AccEndDate_YYYYMMDDHH + $
               '" (required form is YYYYMMDDHH, 10 digits).'
      RETURN
  endif
  if NOT(STREGEX(AccEndDate_YYYYMMDDHH, '[0-9]{10}', /BOOLEAN)) $
      then begin
      ERR_MSG, 'Invalid target accumulation end date/time "' + $
               AccEndDate_YYYYMMDDHH + $
               '" (required form is YYYYMMDDHH, all numeric).'
      RETURN
  endif

  AccEndDate_Julian = YYYYMMDDHH_TO_JULIAN(AccEndDate_YYYYMMDDHH)

  if (DurationHours lt 0) then begin
      ERR_MSG, 'Duration must be a positive integer number of hours.'
      RETURN
  endif

  ;; HRRRDir = '/operations/gisrs/data/snow_model/raster/est_precip'

  ;; if NOT(FILE_TEST(HRRRDir, /DIRECTORY)) then begin
  ;;     ERR_MSG, 'HRRR directory "' + HRRRDir + '" not found.'
  ;;     RETURN
  ;; endif

  ;; if NOT(FILE_TEST(HRRRDir, /READ)) then begin
  ;;     ERR_MSG, 'HRRR directory "' + HRRRDir + '" not readable.'
  ;;     RETURN
  ;; endif

  if NOT(ISA(ScratchDir, 'STRING')) then begin
      ERR_MSG, 'Location of scratch directory must be a STRING.'
      RETURN
  endif

  if NOT(FILE_TEST(ScratchDir, /DIRECTORY)) then begin
      ERR_MSG, 'Scratch directory "' + ScratchDir + '" not found.'
      RETURN
  endif

  if NOT(FILE_TEST(ScratchDir, /READ)) then begin
      ERR_MSG, 'Scratch directory "' + ScratchDir + '" not readable.'
      RETURN
  endif

  if NOT(FILE_TEST(ScratchDir, /WRITE)) then begin
      ERR_MSG, 'Scratch directory "' + ScratchDir + '" not writeable.'
      RETURN
  endif

  if NOT(ISA(Ndv, 'FLOAT')) then $
      ERR_MSG, 'WARNING: no-data value should be a floating point value.'

  savFile = 'NSA_RAP_PRECIP' + $
            '_f' + STRING(TargetFcstHour, FORMAT = '(I2.2)') + $
            '_' + STRCRA(DurationHours) + 'h' + $
            '_ending_' + AccEndDate_YYYYMMDDHH + '.sav'

  if (FILE_TEST(ScratchDir + '/' + savFile)) then begin

;+
;     Get data from cache file rather than reading RAP data
;     directly.
;-
      if KEYWORD_SET(verbose) then $
          USR_MSG, 'Reading ' + ScratchDir + '/' + savFile

      RESTORE, ScratchDir + '/' + savFile

;+
;     Verify the contents of the save file.
;-
      if NOT(ISA(accNonSnowGrid_)) then begin
          ERR_MSG, 'No "accNonSnowGrid_" variable in ' + $
                   ScratchDir + '/' + savFile
          RETURN
      endif

      foo = SIZE(accNonSnowGrid_)
      if (foo[0] ne 2) then begin
          ERR_MSG, 'Non-snow accumulation grid in ' + $
                   ScratchDir + '/' + saveFile + $
                   ' is not a 2-D array.'
          RETURN
      endif

      nCols = foo[1]
      nRows = foo[2]

      if NOT(ISA(accSnowGrid_)) then begin
          ERR_MSG, 'No "accSnowGrid_" variable in ' + $
                   ScratchDir + '/' + savFile
          RETURN
      endif

      foo = SIZE(accSnowGrid_)
      if (foo[0] ne 2) then begin
          ERR_MSG, 'Snow accumulation grid in ' + $
                   ScratchDir + '/' + saveFile + $
                   ' is not a 2-D array.'
          RETURN
      endif

      if (foo[1] ne nCols) then begin
          ERR_MSG, 'Snow accumulation grid column dimension (' + $
                   STRCRA(foo[1]) + ') ' + $
                   'does not match that of non-snow accumulation grid (' + $
                   STRCRA(nCols) + $
                   ').'
          RETURN
      endif

      if (foo[2] ne nRows) then begin
          ERR_MSG, 'Snow accumulation grid row dimension (' + $
                   STRCRA(foo[2]) + ') ' + $
                   'does not match that of non-snow accumulation grid (' + $
                   STRCRA(nRows) + $
                   ').'
          RETURN
      endif

      if NOT(ISA(ndv_)) then begin
          ERR_MSG, 'Missing "ndv_" variable in ' + $
                   ScratchDir + '/' + savFile
          RETURN
      endif

      if NOT(ISA(NSAGridInfo_)) then begin
          ERR_MSG, 'No NSA grid info structure in ' + $
                   ScratchDir + '/' + savFile
          RETURN
      endif

;+
;     Verify the structure of NSAGridInfo_ and grid dimensions.
;-
      foo = SIZE(NSAGridInfo_)
      if (foo[0] ne 1) then begin
          ERR_MSG, 'NSA_GRID_INFO structure mismatch (non-scalar) ' + $
                   'in ' + ScratchDir + '/' + savFile
          RETURN
      endif

      if ((foo[1] ne 1) or (foo[2] ne 8)) then begin
          ERR_MSG, 'NSA_GRID_INFO structure mismatch ' + $
                   '(not a structure) ' + $
                   'in ' + ScratchDir + '/' + savFile
          RETURN
      endif

      savFileOK = 1
      tagNames = TAG_NAMES(NSAGridInfo_)

      ind = WHERE(tagNames eq 'MINLON', count)
      if (count eq 0) then begin
          ERR_MSG, 'No "minLon" tag in NSA_GRID_INFO.'
          savFileOK = 0
      endif

      ind = WHERE(tagNames eq 'MAXLON', count)
      if (count eq 0) then begin
          ERR_MSG, 'No "maxLon" tag in NSA_GRID_INFO.'
          savFileOK = 0
      endif

      ind = WHERE(tagNames eq 'LONRES', count)
      if (count eq 0) then begin
          ERR_MSG, 'No "lonRes" tag in NSA_GRID_INFO.'
          savFileOK = 0
      endif

      ind = WHERE(tagNames eq 'NUMLON', count)
      if (count eq 0) then begin
          ERR_MSG, 'No "numLon" tag in NSA_GRID_INFO.'
          savFileOK = 0
      endif

      ind = WHERE(tagNames eq 'MINLAT', count)
      if (count eq 0) then begin
          ERR_MSG, 'No "minLat" tag in NSA_GRID_INFO.'
          savFileOK = 0
      endif

      ind = WHERE(tagNames eq 'MAXLAT', count)
      if (count eq 0) then begin
          ERR_MSG, 'No "maxLat" tag in NSA_GRID_INFO.'
          savFileOK = 0
      endif

      ind = WHERE(tagNames eq 'LATRES', count)
      if (count eq 0) then begin
          ERR_MSG, 'No "latRes" tag in NSA_GRID_INFO.'
          savFileOK = 0
      endif

      ind = WHERE(tagNames eq 'NUMLAT', count)
      if (count eq 0) then begin
          ERR_MSG, 'No "numLat" tag in NSA_GRID_INFO.'
          savFileOK = 0
      endif

      if savFileOK then begin

          if NOT(ISA(NSAGridInfo_.minLon, 'DOUBLE')) then begin
              ERR_MSG, 'NSA_GRID_INFO missing DOUBLE element ' + $
                       '"minLon" ' + $
                       'in ' + ScratchDir + '/' + savFile
              savFileOK = 0
          endif

          if NOT(ISA(NSAGridInfo_.maxLon, 'DOUBLE')) then begin
              ERR_MSG, 'NSA_GRID_INFO missing DOUBLE element ' + $
                       '"maxLon" ' + $
                       'in ' + ScratchDir + '/' + savFile
              savFileOK = 0
          endif

          if NOT(ISA(NSAGridInfo_.lonRes, 'DOUBLE')) then begin
              ERR_MSG, 'NSA_GRID_INFO missing DOUBLE element ' + $
                       '"lonRes" ' + $
                       'in ' + ScratchDir + '/' + savFile
              savFileOK = 0
          endif

          if NOT(ISA(NSAGridInfo_.numLon, 'LONG')) then begin
              ERR_MSG, 'NSA_GRID_INFO missing LONG element ' + $
                       '"numLon" ' + $
                       'in ' + ScratchDir + '/' + savFile
              savFileOK = 0
          endif

          if NOT(ISA(NSAGridInfo_.minLat, 'DOUBLE')) then begin
              ERR_MSG, 'NSA_GRID_INFO missing DOUBLE element ' + $
                       '"minLat" ' + $
                       'in ' + ScratchDir + '/' + savFile
              savFileOK = 0
          endif

          if NOT(ISA(NSAGridInfo_.maxLat, 'DOUBLE')) then begin
              ERR_MSG, 'NSA_GRID_INFO missing DOUBLE element ' + $
                       '"maxLat" ' + $
                       'in ' + ScratchDir + '/' + savFile
              savFileOK = 0
          endif

          if NOT(ISA(NSAGridInfo_.latRes, 'DOUBLE')) then begin
              ERR_MSG, 'NSA_GRID_INFO missing DOUBLE element ' + $
                       '"latRes" ' + $
                       'in ' + ScratchDir + '/' + savFile
              savFileOK = 0
          endif

          if NOT(ISA(NSAGridInfo_.numLat, 'LONG')) then begin
              ERR_MSG, 'NSA_GRID_INFO missing LONG element ' + $
                       '"numLat" ' + $
                       'in ' + ScratchDir + '/' + savFile
              savFileOK = 0
          endif

          if (nCols ne NSAGridInfo_.numLon) then begin
              ERR_MSG, 'Grid columns in ' + $
                       ScratchDir + '/' + savFile + $
                       ' (' + STRCRA(nCols) + ') ' + $
                       'do not match NSA_GRID_INFO value ' + $
                       '(' + STRCRA(NSAGridInfo_.numLon) + ').'
              savFileOK = 0
          endif

          if (nRows ne NSAGridInfo_.numLat) then begin
              ERR_MSG, 'Grid rows in ' + $
                       ScratchDir + '/' + savFile + $
                       ' (' + STRCRA(numLat) + ') ' + $
                       'do not match NSA_GRID_INFO value ' + $
                       '(' + STRCRA(NSAGridInfo_.numLat) + ').'
              savFileOK = 0
          endif

      endif

      if (savFileOK and KEYWORD_SET(NSAGridInfo)) then begin

;+
;         Verify NSAGridInfo structure from caller against
;         NSAGridInfo_ structure from save file.
;-
          if NOT(COMPARE(NSAGridInfo.minLon, NSAGridInfo_.minLon)) $
              then begin
              ERR_MSG, 'NSA_GRID_INFO structure "minLon" mismatch ' + $
                       'between keyword and ' + $
                       ScratchDir + '/' + savFile + ' data.'
              savFileOK = 0
          endif

          if NOT(COMPARE(NSAGridInfo.maxLon, NSAGridInfo_.maxLon)) $
              then begin
              ERR_MSG, 'NSA_GRID_INFO structure "maxLon" mismatch ' + $
                       'between keyword and ' + $
                       ScratchDir + '/' + savFile + ' data.'
              savFileOK = 0
          endif

          if NOT(COMPARE(NSAGridInfo.lonRes, $
                         NSAGridInfo_.lonRes)) $
              then begin
              ERR_MSG, 'NSA_GRID_INFO structure "lonRes" ' + $
                       'mismatch between keyword and ' + $
                       ScratchDir + '/' + savFile + ' data.'
              savFileOK = 0
          endif

          if (NSAGridInfo.numLon ne NSAGridInfo_.numLon) then begin
              ERR_MSG, 'NSA_GRID_INFO structure "numLon" mismatch ' + $
                       'between keyword and ' + $
                       ScratchDir + '/' + savFile + ' data.'
              savFileOK = 0
          endif

          if NOT(COMPARE(NSAGridInfo.minLat, $
                         NSAGridInfo_.minLat)) $
              then begin
              ERR_MSG, 'NSA_GRID_INFO structure "minLat" ' + $
                       'mismatch between keyword and ' + $
                       ScratchDir + '/' + savFile + ' data.'
              savFileOK = 0
          endif

          if NOT(COMPARE(NSAGridInfo.maxLat, $
                         NSAGridInfo_.maxLat)) $
              then begin
              ERR_MSG, 'NSA_GRID_INFO structure "maxLat" ' + $
                       'mismatch between keyword and ' + $
                       ScratchDir + '/' + savFile + ' data.'
              savFileOK = 0
          endif

          if NOT(COMPARE(NSAGridInfo.latRes, NSAGridInfo_.latRes)) $
              then begin
              ERR_MSG, 'NSA_GRID_INFO structure "latRes" mismatch ' + $
                       'between keyword and ' + $
                       ScratchDir + '/' + savFile + ' data.'
              savFileOK = 0
          endif

          if (NSAGridInfo.numLat ne NSAGridInfo_.numLat) then begin
              ERR_MSG, 'NSA_GRID_INFO structure "numLat" mismatch ' + $
                       'between keyword and ' + $
                       ScratchDir + '/' + savFile + ' data.'
              savFileOK = 0
          endif

      endif else begin


;         Copy NSAGridInfo structure from save file.

          if savFileOK then NSAGridInfo = NSAGridInfo_

      endelse

      if NOT(savFileOK) then begin

          ERR_MSG, 'Unexpected structure/content in IDL save file ' + $
                   savFile + '; returning NULL grids.'
          RETURN

      endif

;+
;     Verify the no-data value is consistent; modify if it is not.
;-
      if (ndv_ ne Ndv) then begin
          ERR_MSG, 'WARNING: value of "ndv_" variable in ' + $
                  ScratchDir + '/' + savFile + $
                  ' (' + STRCRA(ndv_) + ') differs from ' + $
                  ' argument "Ndv" ' + $
                  '(' + STRCRA(Ndv) + '). Will adapt.'
          ind = WHERE(accNonSnowGrid_ eq ndv_, count)
          if (count gt 0) then accNonSnowGrid_[ind] = Ndv
          ind = WHERE(accSnowGrid_ eq ndv_, count)
          if (count gt 0) then accSnowGrid_[ind] = Ndv
          ind = !NULL
      endif

      accNonSnowGrid = TEMPORARY(accNonSnowGrid_)
      accSnowGrid = TEMPORARY(accSnowGrid_)

      RETURN

  endif

  perfect = 1B ; flag to indicate that we got our first choice for
               ; all input QPF grids

;+
; Sample layer names:
;
; "Scaled CRR non-snow precipitation 3hr 2018-01-02 12"
; "Scaled CRR snow precipitation 3hr 2018-01-02 12"
;-
  for hc = 0, DurationHours - 1 do begin

      cycleDate_Julian = AccEndDate_Julian - $
                         DOUBLE(DurationHours - 1) / 24.0D + $
                         DOUBLE(hc) / 24.0D - $
                         DOUBLE(TargetFcstHour) / 24.0D

      ;; cycleDate_YYYYMMDDHH = JULIAN_TO_YYYYMMDDHH(cycleDate_Julian)
      ;; cycleDate_YYYY = STRMID(cycleDate_YYYYMMDDHH, 0, 4)
      ;; cycleDate_MM = STRMID(cycleDate_YYYYMMDDHH, 4, 2)
      ;; cycleDate_DD = STRMID(cycleDate_YYYYMMDDHH, 6, 2)
      ;; cycleDate_HH = STRMID(cycleDate_YYYYMMDDHH, 8, 2)

      cycleDate_GISRS = JULIAN_TO_GISRS_DATE(cycleDate_Julian)

      nonSnowFilePath = ''
      snowFilePath = ''

;+
;     Check for non-snow layer.
;-
      nonSnowLayer = 'Scaled CRR non-snow precipitation ' + $
                     STRCRA(TargetFcstHour) + 'hr ' + $
                     cycleDate_GISRS

      statement = 'psql -d operations -h ' + PGHost + ' -t -A -c ' + $
                  '"' + $
                  'set search_path = gisrs; ' + $
                  'select ' + $
                  'trim(data_file_pathname) ' + $
                  'from estimated_precip ' + $
                  'where gis_layer = ''' + nonSnowLayer + ''';"'

      SPAWN, statement, nonSnowFilePath, EXIT_STATUS = status

      if (status ne 0) then begin
          ERR_MSG, 'psql statement failed: ' + statement
          RETURN
      endif

      if (N_ELEMENTS(nonSnowFilePath) ne 1) then begin
          ERR_MSG, 'Unexpected query result.'
          RETURN
      endif

      nonSnowFilePath = nonSnowFilePath[0]

      if (nonSnowFilePath ne '') then begin

;+
;         Check for snow layer.
;-
          snowLayer = 'Scaled CRR snow precipitation ' + $
                      STRCRA(TargetFcstHour) + 'hr ' + $
                      cycleDate_GISRS

          statement = 'psql -d operations -h ' + PGHost + $
                      ' -t -A -c ' + $
                      '"' + $
                      'set search_path = gisrs; ' + $
                      'select ' + $
                      'trim(data_file_pathname) ' + $
                      'from estimated_precip ' + $
                      'where gis_layer = ''' + snowLayer + ''';"'

          SPAWN, statement, snowFilePath, EXIT_STATUS = status

          if (status ne 0) then begin
              ERR_MSG, 'psql statement failed: ' + statement
              RETURN
          endif

          if (N_ELEMENTS(snowFilePath) ne 1) then begin
              ERR_MSG, 'Unexpected query result.'
              RETURN
          endif

          snowFilePath = snowFilePath[0]

      endif

      if ((nonSnowFilePath eq '') or (snowFilePath eq '')) then begin

          perfect = 0B

;+
;         Try a farther-out forecast.
;-
          altFcstHour = TargetFcstHour + 1

          while (altFcstHour le MaxSubFcstHour) do begin

              cycleDate_Julian = AccEndDate_Julian - $
                                 DOUBLE(DurationHours - 1) / 24.0D + $
                                 DOUBLE(hc) / 24.0D - $
                                 DOUBLE(altFcstHour) / 24.0D

              ;; cycleDate_YYYYMMDDHH = JULIAN_TO_YYYYMMDDHH(cycleDate_Julian)
              ;; cycleDate_YYYY = STRMID(cycleDate_YYYYMMDDHH, 0, 4)
              ;; cycleDate_MM = STRMID(cycleDate_YYYYMMDDHH, 4, 2)
              ;; cycleDate_DD = STRMID(cycleDate_YYYYMMDDHH, 6, 2)

              cycleDate_GISRS = JULIAN_TO_GISRS_DATE(cycleDate_Julian)

;+
;             Check for non-snow layer.
;-
              nonSnowLayer = 'Scaled CRR non-snow precipitation ' + $
                             STRCRA(altFcstHour) + 'hr ' + $
                             cycleDate_GISRS

              statement = 'psql -d operations -h ' + PGHost + ' -t -A -c ' + $
                          '"' + $
                          'set search_path = gisrs; ' + $
                          'select ' + $
                          'trim(data_file_pathname) ' + $
                          'from estimated_precip ' + $
                          'where gis_layer = ''' + nonSnowLayer + ''';"'

              SPAWN, statement, nonSnowFilePath, EXIT_STATUS = status

              if (status ne 0) then begin
                  ERR_MSG, 'psql statement failed: ' + statement
                  RETURN
              endif

              if (N_ELEMENTS(nonSnowFilePath) ne 1) then begin
                  ERR_MSG, 'Unexpected query result.'
                  RETURN
              endif

              nonSnowFilePath = nonSnowFilePath[0]

              if (nonSnowFilePath ne '') then begin

;+
;                 Check for snow layer.
;-
                  snowLayer = 'Scaled CRR snow precipitation ' + $
                              STRCRA(altFcstHour) + 'hr ' + $
                              cycleDate_GISRS

                  statement = 'psql -d operations -h ' + PGHost + $
                              ' -t -A -c ' + $
                              '"' + $
                              'set search_path = gisrs; ' + $
                              'select ' + $
                              'trim(data_file_pathname) ' + $
                              'from estimated_precip ' + $
                              'where gis_layer = ''' + snowLayer + ''';"'

                  SPAWN, statement, snowFilePath, EXIT_STATUS = status

                  if (status ne 0) then begin
                      ERR_MSG, 'psql statement failed: ' + statement
                      RETURN
                  endif

                  if (N_ELEMENTS(snowFilePath) ne 1) then begin
                      ERR_MSG, 'Unexpected query result.'
                      RETURN
                  endif

                  snowFilePath = snowFilePath[0]

              endif

              if ((nonSnowFilePath ne '') and $
                  (snowFilePath ne '')) then BREAK

              altFcstHour = altFcstHour + 1

          endwhile

          if ((altFcstHour le MaxSubFcstHour) and $
              KEYWORD_SET(verbose)) then $
              USR_MSG, 'WARNING: using ' + $
                       STRCRA(altFcstHour) + $
                       '-hour forecast for hour ' + $
                       STRCRA(hc + 1)

      endif

      if ((nonSnowFilePath eq '') or (snowFilePath eq '')) then begin

;+
;         Try a less-far-out forecast.
;-
          altFcstHour = TargetFcstHour - 1

          while (altFcstHour ge MinSubFcstHour) do begin

              cycleDate_Julian = AccEndDate_Julian - $
                                 DOUBLE(DurationHours - 1) / 24.0D + $
                                 DOUBLE(hc) / 24.0D - $
                                 DOUBLE(altFcstHour) / 24.0D

              ;; cycleDate_YYYYMMDDHH = JULIAN_TO_YYYYMMDDHH(cycleDate_Julian)
              ;; cycleDate_YYYY = STRMID(cycleDate_YYYYMMDDHH, 0, 4)
              ;; cycleDate_MM = STRMID(cycleDate_YYYYMMDDHH, 4, 2)
              ;; cycleDate_DD = STRMID(cycleDate_YYYYMMDDHH, 6, 2)

              cycleDate_GISRS = JULIAN_TO_GISRS_DATE(cycleDate_Julian)

;+
;             Check for non-snow layer.

              nonSnowLayer = 'Scaled CRR non-snow precipitation ' + $
                             STRCRA(altFcstHour) + 'hr ' + $
                             cycleDate_GISRS

              statement = 'psql -d operations -h ' + PGHost + ' -t -A -c ' + $
                          '"' + $
                          'set search_path = gisrs; ' + $
                          'select ' + $
                          'trim(data_file_pathname) ' + $
                          'from estimated_precip ' + $
                          'where gis_layer = ''' + nonSnowLayer + ''';"'

              SPAWN, statement, nonSnowFilePath, EXIT_STATUS = status

              if (status ne 0) then begin
                  ERR_MSG, 'psql statement failed: ' + statement
                  RETURN
              endif

              if (N_ELEMENTS(nonSnowFilePath) ne 1) then begin
                  ERR_MSG, 'Unexpected query result.'
                  RETURN
              endif

              nonSnowFilePath = nonSnowFilePath[0]

              if (nonSnowFilePath ne '') then begin

;+
;                 Check for snow layer.
;-
                  snowLayer = 'Scaled CRR snow precipitation ' + $
                              STRCRA(altFcstHour) + 'hr ' + $
                              cycleDate_GISRS

                  statement = 'psql -d operations -h ' + PGHost + $
                              ' -t -A -c ' + $
                              '"' + $
                              'set search_path = gisrs; ' + $
                              'select ' + $
                              'trim(data_file_pathname) ' + $
                              'from estimated_precip ' + $
                              'where gis_layer = ''' + snowLayer + ''';"'

                  SPAWN, statement, snowFilePath, EXIT_STATUS = status

                  if (status ne 0) then begin
                      ERR_MSG, 'psql statement failed: ' + statement
                      RETURN
                  endif

                  if (N_ELEMENTS(snowFilePath) ne 1) then begin
                      ERR_MSG, 'Unexpected query result.'
                      RETURN
                  endif

                  snowFilePath = snowFilePath[0]

              endif

              if ((nonSnowFilePath ne '') and $
                  (snowFilePath ne '')) then BREAK

              altFcstHour = altFcstHour - 1

          endwhile

          if ((altFcstHour ge MinSubFcstHour) and $
              KEYWORD_SET(verbose)) then $
              USR_MSG, 'WARNING: using ' + $
                       STRCRA(altFcstHour) + $
                       '-hour forecast for hour ' + $
                       STRCRA(hc + 1)
      endif

      if ((nonSnowFilePath eq '') or (snowFilePath eq '')) then begin
          if KEYWORD_SET(verbose) then $
              ERR_MSG, 'No data found for hour ' + STRCRA(hc) + $
                       ' of RAP accumulation ending ' + $
                       AccEndDate_YYYYMMDDHH + '.'
          RETURN
      endif

      fcstHour = TargetFcstHour
      if ISA(altFcstHour) then fcstHour = altFcstHour

;+
;     Verify the layers are stored in NetCDF files.
;-
      if (STRMID(nonSnowFilePath, 2, 3, /REVERSE_OFFSET) ne '.nc') then begin
          ERR_MSG, 'Query result "' + nonSnowFilePath + '" ' + $
                   'does not have the expected ".nc" extension.'
          RETURN
      endif

      if (STRMID(snowFilePath, 2, 3, /REVERSE_OFFSET) ne '.nc') then begin
          ERR_MSG, 'Query result "' + snowFilePath + '" ' + $
                   'does not have the expected ".nc" extension.'
          RETURN
      endif

;+
;     Read non-snow precipitation.
;-

      nonSnowFileDir = FILE_DIRNAME(nonSnowFilePath)
      nonSnowFileName = FILE_BASENAME(nonSnowFilePath)

      hourlyNonSnowGrid = !NULL

      if KEYWORD_SET(verbose) then $
          USR_MSG, 'Reading layer "' + nonSnowLayer + '"'

      GET_LONLAT_NETCDF_DATA, nonSnowFileDir, $
                              nonSnowFileName, $
                              NSAGridInfo_, $
                              hourlyNonSnowGrid, $
                              NO_DATA_VALUE = ndv_

      if NOT(ISA(hourlyNonSnowGrid)) then STOP

      if (Ndv ne ndv_) then begin
          ind = WHERE(hourlyNonSnowGrid eq ndv_, count)
          if (count gt 0) then hourlyNonSnowGrid[ind] = Ndv
      endif

      foo = SIZE(hourlyNonSnowGrid)
      nCols_ = foo[1]
      nRows_ = foo[2]

      if (nCols_ ne NSAGridInfo_.numLon) then begin
          ERR_MSG, 'Grid size is inconsistent with "numLon" structure ' + $
                   'tag. Programming error in GET_LONLAT_NETCDF_DATA.'
          RETURN
      endif

      if (nRows_ ne NSAGridInfo_.numLat) then begin
          ERR_MSG, 'Grid size is inconsistent with "numLat" structure ' + $
                   'tag. Programming error in GET_LONLAT_NETCDF_DATA.'
          RETURN
      endif

      if (hc eq 0) then begin

;+
;         Establish grid size and projection parameters.
;-
          nCols = nCols_
          nRows = nRows_

          if NOT(KEYWORD_SET(NSAGridInfo)) then begin

              NSAGridInfo = NSAGridInfo_

          endif else begin

;+
;             Verify NSAGridInfo structure from caller against
;             NSAGridInfo_ generated from reading NetCDF file.
;-
              foo = SIZE(NSAGridInfo)
              if (foo[0] ne 1) then begin
                  ERR_MSG, 'NSA_GRID_INFO structure mismatch ' + $
                           '(non-scalar).'
                  RETURN
              endif

              if ((foo[1] ne 1) or (foo[2] ne 8)) then begin
                  ERR_MSG, 'NSA_GRID_INFO structure mismatch ' + $
                           '(not a structure).'
                  RETURN
              endif

              tagNames = TAG_NAMES(NSAGridInfo)
              ind = WHERE(tagNames eq 'MINLON', count)
              if (count eq 0) then begin
                  ERR_MSG, 'No "minLon" tag in NSA_GRID_INFO.'
                  RETURN
              endif

              ind = WHERE(tagNames eq 'MAXLON', count)
              if (count eq 0) then begin
                  ERR_MSG, 'No "maxLon" tag in NSA_GRID_INFO.'
                  RETURN
              endif

              ind = WHERE(tagNames eq 'LONRES', count)
              if (count eq 0) then begin
                  ERR_MSG, 'No "lonRes" tag in NSA_GRID_INFO.'
                  RETURN
              endif

              ind = WHERE(tagNames eq 'NUMLON', count)
              if (count eq 0) then begin
                  ERR_MSG, 'No "numLon" tag in NSA_GRID_INFO.'
                  RETURN
              endif

              ind = WHERE(tagNames eq 'MINLAT', count)
              if (count eq 0) then begin
                  ERR_MSG, 'No "minLat" tag in NSA_GRID_INFO.'
                  RETURN
              endif

              ind = WHERE(tagNames eq 'MAXLAT', count)
              if (count eq 0) then begin
                  ERR_MSG, 'No "maxLat" tag in NSA_GRID_INFO.'
                  RETURN
              endif

              ind = WHERE(tagNames eq 'LATRES', count)
              if (count eq 0) then begin
                  ERR_MSG, 'No "latRes" tag in NSA_GRID_INFO.'
                  RETURN
              endif

              ind = WHERE(tagNames eq 'NUMLAT', count)
              if (count eq 0) then begin
                  ERR_MSG, 'No "numLat" tag in NSA_GRID_INFO.'
                  RETURN
              endif

              if NOT(COMPARE(NSAGridInfo.minLon, NSAGridInfo_.minLon)) $
                  then begin
                  ERR_MSG, 'NSA_GRID_INFO structure "minLon" mismatch.'
                  RETURN
              endif

              if NOT(COMPARE(NSAGridInfo.maxLon, NSAGridInfo_.maxLon)) $
                  then begin
                  ERR_MSG, 'NSA_GRID_INFO structure "maxLon" mismatch.'
                  RETURN
              endif

              if NOT(COMPARE(NSAGridInfo.lonRes, NSAGridInfo_.lonRes)) $
                  then begin
                  ERR_MSG, 'NSA_GRID_INFO structure "lonRes" ' + $
                           'mismatch.'
                  RETURN
              endif

              if (NSAGridInfo.numLon ne NSAGridInfo_.numLon) then begin
                  ERR_MSG, 'NSA_GRID_INFO structure "numLon" mismatch.'
                  RETURN
              endif

              if NOT(COMPARE(NSAGridInfo.minLat, NSAGridInfo_.minLat)) $
                  then begin
                  ERR_MSG, 'NSA_GRID_INFO structure "minLat" ' + $
                           'mismatch.'
                  RETURN
              endif

              if NOT(COMPARE(NSAGridInfo.maxLat, NSAGridInfo_.maxLat)) $
                  then begin
                  ERR_MSG, 'NSA_GRID_INFO structure "maxLat" ' + $
                           'mismatch.'
                  RETURN
              endif

              if NOT(COMPARE(NSAGridInfo.latRes, NSAGridInfo_.latRes)) $
                  then begin
                  ERR_MSG, 'NSA_GRID_INFO structure "latRes" ' + $
                           'mismatch.'
                  RETURN
              endif

              if (NSAGridInfo.numLat ne NSAGridInfo_.numLat) then begin
                  ERR_MSG, 'NSA_GRID_INFO structure "numLat" mismatch.'
                  RETURN
              endif

          endelse

          accNonSnowGrid_ = hourlyNonSnowGrid

      endif else begin

          if (nCols_ ne nCols) then begin
              ERR_MSG, 'Grid columns in ' + nonSnowFilePath + $
                       ' differ from those from previous hour/s.'
              RETURN
          endif

          if (nRows_ ne nRows) then begin
              ERR_MSG, 'Grid rows in ' + nonSnowFilePath + $
                       ' differ from those from previous hour/s.'
              RETURN
          endif

          ind = WHERE((accNonSnowGrid_ eq Ndv) or $
                      (hourlyNonSnowGrid eq Ndv), count)
          accNonSnowGrid_ = accNonSnowGrid_ + hourlyNonSnowGrid
          if (count gt 0) then accNonSnowGrid_[ind] = Ndv

      endelse

;+
;     Read snow precipitation.
;-
      snowFileDir = FILE_DIRNAME(snowFilePath)
      snowFileName = FILE_BASENAME(snowFilePath)

      hourlySnowGrid = !NULL

      if KEYWORD_SET(verbose) then $
          USR_MSG, 'Reading layer "' + snowLayer + '"'

      GET_LONLAT_NETCDF_DATA, snowFileDir, $
                              snowFileName, $
                              NSAGridInfo_, $
                              hourlySnowGrid, $
                              NO_DATA_VALUE = ndv_

      if NOT(ISA(hourlySnowGrid)) then STOP

      if (Ndv ne ndv_) then begin
          ind = WHERE(hourlySnowGrid eq ndv_, count)
          if (count gt 0) then hourlySnowGrid[ind] = Ndv
      endif

      foo = SIZE(hourlySnowGrid)
      nCols_ = foo[1]
      nRows_ = foo[2]

      if (nCols_ ne NSAGridInfo_.numLon) then begin
          ERR_MSG, 'Grid size is inconsistent with "numLon" structure ' + $
                   'tag. Programming error in GET_LONLAT_NETCDF_DATA.'
          RETURN
      endif

      if (nRows_ ne NSAGridInfo_.numLat) then begin
          ERR_MSG, 'Grid size is inconsistent with "numLat" structure ' + $
                   'tag. Programming error in GET_LONLAT_NETCDF_DATA.'
          RETURN
      endif

;+
;     Verify structure of hourly snow QPF.
;-
      if (nCols_ ne nCols) then begin
          ERR_MSG, 'Grid columns in ' + snowFilePath + $
                   ' differ from those from previous hour/s.'
          RETURN
      endif

      if (nRows_ ne nRows) then begin
          ERR_MSG, 'Grid rows in ' + snowFilePath + $
                   ' differ from those from previous hour/s.'
          RETURN
      endif

      if (hc eq 0) then begin

          accSnowGrid_ = hourlySnowGrid

      endif else begin

          ind = WHERE((accSnowGrid_ eq Ndv) or $
                      (hourlySnowGrid eq Ndv), count)
          accSnowGrid_ = accSnowGrid_ + hourlySnowGrid
          if (count gt 0) then accSnowGrid_[ind] = Ndv

      endelse

      altFcstHour = !NULL

  endfor

;+
; Free memory.
;-
  hourlyNonSnowGrid = !NULL
  hourlySnowGrid = !NULL

  if perfect then begin

;+
;     Create a cached copy of results for future calls to this
;     procedure with the same set of arguments.
;-
      ndv_ = Ndv

      NSAGridInfo_ = NSAGridInfo

      SAVE, accNonSnowGrid_, accSnowGrid_, $
            ndv_, NSAGridInfo_, $            
            FILE = ScratchDir + '/' + savFile

      if KEYWORD_SET(verbose) then $
          USR_MSG, 'Non-snow and snow accumulation grids saved to ' + $
                   ScratchDir + '/' + savFile

  endif

  accNonSnowGrid = TEMPORARY(accNonSnowGrid_)
  accSnowGrid = TEMPORARY(accSnowGrid_)

  RETURN

end
